# Blog Post Findings

Generated by `make` in `test/blog/`. All data below is from actual compiler output.

## Struct Sizes

| Variant | sizeof | battery_mv offset | Key notes |
|---------|--------|-------------------|-----------|
| pack(1) | 19 | 17 | Minimal size, no padding anywhere |
| packed+aligned(4) | 20 | 17 | 1 byte tail padding (19 rounded up to 20) |
| unpacked | 24 | 18 | 1 byte pad before battery_mv + 4 bytes tail pad |

## Disassembly: RISC-V 32-bit (primary)

### Write int64_t timestamp (offset 0, aligned in all variants)

| Variant | Instructions | Key opcodes | Notes |
|---------|-------------|-------------|-------|
| pack(1) | 14 | `srli` x6 + `sb` x8 | Byte-decomposes BOTH halves of the 64-bit value |
| packed+aligned(4) | 2 | `sw` x2 | Two native 32-bit stores |
| unpacked | 2 | `sw` x2 | Two native 32-bit stores |

This is the strongest demonstration: an aligned field at offset 0 is still byte-decomposed
under pack(1) because the compiler cannot assume the struct itself is aligned. With
packed+aligned(4), the compiler knows the base is 4-aligned, so offset 0 is 4-aligned, and
it emits native `sw` instructions.

### Write int32_t temperature_mc (offset 8, aligned in all variants)

| Variant | Instructions | Key opcodes | Notes |
|---------|-------------|-------------|-------|
| pack(1) | 7 | `srli` x3 + `sb` x4 | 4 byte-stores for a 32-bit value |
| packed+aligned(4) | 1 | `sw` | Single native store |
| unpacked | 1 | `sw` | Single native store |

pack(1) uses 7x more instructions than packed+aligned(4) for the same field at the same
offset. The field IS naturally aligned (offset 8, size 4), but pack(1) forces byte access.

### Write uint16_t battery_mv (offset 17 pack1/pa4, offset 18 unpacked)

| Variant | Instructions | Key opcodes | Notes |
|---------|-------------|-------------|-------|
| pack(1) | 3 | `srli` x1 + `sb` x2 | Byte-decomposed (offset 17, not 2-aligned) |
| packed+aligned(4) | 3 | `srli` x1 + `sb` x2 | Byte-decomposed (offset 17, not 2-aligned) |
| unpacked | 1 | `sh` | Native half-word store (offset 18, 2-aligned) |

This confirms that packed+aligned(4) does NOT blindly use native access -- fields that
are genuinely misaligned (offset 17 is odd) are still correctly byte-decomposed. The
aligned(4) attribute helps only where the math works out.

### Read uint16_t battery_mv

| Variant | Instructions | Key opcodes | Notes |
|---------|-------------|-------------|-------|
| pack(1) | 2 | `lbu` x2 | Two byte-loads (offset 17, not 2-aligned) |
| packed+aligned(4) | 1 | `lw` from offset 16 | Loads full word, caller extracts bytes! |
| unpacked | 1 | `lhu` | Native half-word load (offset 18, 2-aligned) |

**Surprise:** The pa4 read uses `lw a0, 16(a0)` -- a full 32-bit load from offset 16
(which IS 4-aligned given aligned(4) base). The compiler loads 4 bytes and relies on the
caller to shift/mask the result. This is a read optimization: because the compiler knows
offset 16 is 4-aligned relative to a 4-aligned base, it can do a single aligned load and
extract the uint16_t from bytes 17-18 of that word. This is 1 instruction vs pack(1)'s 2
byte-loads.

### Write uint32_t error_code (offset 19, evolved struct)

| Variant | Instructions | Key opcodes | Notes |
|---------|-------------|-------------|-------|
| evolved (pa4) | 7 | `srli` x3 + `sb` x4 | Byte-decomposed (offset 19, not 4-aligned) |

Adding `error_code` after `battery_mv` places it at offset 19 -- not 4-aligned. Even with
aligned(4) on the struct, the compiler correctly byte-decomposes this access. This is
exactly the "silent misalignment" scenario that struct-lint should catch.

## Disassembly: Breadth (Xtensa, ARM Cortex-M0)

### Write int32_t temperature_mc comparison

| Architecture | pack(1) insns | pack(1) opcodes | pa4 insns | pa4 opcodes | unpacked insns | unpacked opcodes |
|-------------|--------------|-----------------|-----------|-------------|---------------|-----------------|
| RISC-V 32 | 7 | 3x `srli` + 4x `sb` | 1 | `sw` | 1 | `sw` |
| Xtensa | 8 | entry + 3x `extui` + 4x `s8i` + retw.n | 3 | entry + `s32i.n` + retw.n | 3 | entry + `s32i.n` + retw.n |
| ARM Cortex-M0 | 9 | 2x `lsrs` + `lsls` + 4x `strb` + `bx lr` + nop | 2 | `str` + `bx lr` | 2 | `str` + `bx lr` |

Note: Xtensa and ARM include function prologue/epilogue instructions (entry/retw.n,
bx lr) in their counts. For a fairer body-only comparison:

| Architecture | pack(1) body | pa4 body | unpacked body | pack(1) / pa4 ratio |
|-------------|-------------|----------|--------------|-------------------|
| RISC-V 32 | 7 | 1 | 1 | 7x |
| Xtensa | 7 (3 extui + 4 s8i) | 1 (s32i.n) | 1 (s32i.n) | 7x |
| ARM Cortex-M0 | 7 (2 lsrs + lsls + 4 strb) | 1 (str) | 1 (str) | 7x |

The 7x instruction ratio for a 32-bit write to an aligned field is consistent across all
three architectures.

## struct-lint Output

```
=== struct-lint on rv32 objects ===
../../target/debug/struct-lint -v out/rv32/ || true
sensor_reading.c/sensor_reading.c:19: timestamp.timestamp (timestamp, 2 bytes) at offset 17 not naturally aligned (needs 2)
Users/cmerck/src/chrismerck/struct-lint/test/blog:14: timestamp.timestamp (timestamp, 2 bytes) at offset 17 not naturally aligned (needs 2)
Users/cmerck/src/chrismerck/struct-lint/test/blog:14: timestamp.timestamp (timestamp, 4 bytes) at offset 19 not naturally aligned (needs 4)
sensor_reading.c/sensor_reading.c:54: timestamp (24 bytes, 5 members) ok

3 issues in 2 structs across 2 files (3 alignment, 0 missing pack)

=== struct-lint on evolved struct ===
../../target/debug/struct-lint out/rv32/sensor_reading_evolved.o || true
Users/cmerck/src/chrismerck/struct-lint/test/blog:14: timestamp.timestamp (timestamp, 2 bytes) at offset 17 not naturally aligned (needs 2)
Users/cmerck/src/chrismerck/struct-lint/test/blog:14: timestamp.timestamp (timestamp, 4 bytes) at offset 19 not naturally aligned (needs 4)

2 issues in 1 structs across 1 file (2 alignment, 0 missing pack)
```

Note: struct-lint is correctly detecting the misaligned members (battery_mv at offset 17,
error_code at offset 19) in the packed structs. The struct names appear as "timestamp"
rather than the typedef names -- this is a known limitation with how DWARF represents
packed structs (the struct is anonymous, and the typedef chain resolution picks up a
member name instead).

## Claims Verification

| # | Claim | Verified? | Notes |
|---|-------|-----------|-------|
| 0 | Unpacked structs waste space | YES | 24 bytes vs 19 bytes = 26% overhead (5 bytes padding) |
| 1 | pack(1) byte-decomposes ALL field accesses | YES | Even timestamp at offset 0 (perfectly aligned) gets 8 sb instructions on rv32 |
| 2 | packed+aligned(4) generates native access for aligned fields | YES | temperature_mc@8: 1 `sw` vs 7 instructions. timestamp@0: 2 `sw` vs 14 instructions |
| 3 | Genuinely misaligned fields still byte-decomposed with pa4 | YES | battery_mv@17 uses `sb` x2 in both pack1 and pa4 variants |
| 4 | Reads of misaligned fields can be optimized with known base alignment | YES | read_bat_pa4 uses a single `lw` from aligned offset 16 then shifts, vs 2 `lbu` for pack1 |
| 5 | This isn't platform-specific | YES | All three architectures (rv32, Xtensa, ARM-M0) show identical 7x ratio for write_temp |
| 6 | Adding a field silently creates misalignment | YES | error_code@19 in evolved struct gets 4 `sb` (7 instructions total) |
| 7 | aligned(4) changes array stride | YES | sizeof goes from 19 to 20 (static_assert confirms) |

## Surprises / Adjustments Needed

1. **read_bat_pa4 optimization is more aggressive than expected.** The compiler does not
   byte-load the misaligned uint16_t at all -- it loads a full aligned 32-bit word from
   offset 16 and lets the caller extract the needed bytes. This is a stronger optimization
   than "just use native loads for aligned fields." The compiler is using the known base
   alignment to find a nearby aligned address and load from there. This deserves a callout
   in the blog post.

2. **struct-lint name resolution is imperfect.** The struct names in the output show as
   "timestamp" rather than the actual typedef names (sensor_reading_pack1_t, etc.). This
   appears to be a DWARF/typedef resolution issue. The file paths are also slightly off
   (showing just the directory for the evolved struct). Not critical for the blog post but
   worth noting.

3. **pack(1) byte-decomposes even offset-0 fields.** This is actually the most dramatic
   example -- 14 instructions vs 2 for writing a 64-bit value that is naturally aligned in
   every possible way. The blog draft may want to lead with this example rather than the
   temperature_mc one.

4. **ARM Cortex-M0 includes a `nop` for alignment** in the pack1 variant (padding the
   function to 4-byte alignment). The `lsls` instruction is also interesting -- ARM uses a
   left-shift then right-shift sequence for some byte extractions, which is slightly
   different from RISC-V's pure right-shift approach, but the overall pattern is the same.

5. **No crashes or traps observed in this experiment.** All architectures generated correct
   (if slow) code for misaligned accesses. The danger of unaligned access traps is
   real on Xtensa (LoadStoreAlignment exception) but only manifests at runtime if the
   compiler were to emit native loads for misaligned offsets, which it does not do for
   packed structs. The risk is primarily from *missing* pack annotations, where the
   compiler assumes natural alignment but the data arrives packed over the wire.
